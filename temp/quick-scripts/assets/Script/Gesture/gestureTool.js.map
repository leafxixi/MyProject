{"version":3,"sources":["gestureTool.js"],"names":["DollarRecognizer","require","gesture","cc","Class","extends","Component","properties","GestureAction_A","default","type","Label","GestureAction_B","GestureAction_C","myGraphics","Graphics","setEventControl","self","_isDown","graphics","gestureAction_A","gestureAction_B","gestureAction_C","gestureActionCount","eventManager","addListener","event","EventListener","TOUCH_ONE_BY_ONE","swallowTouches","onTouchBegan","touch","string","target","getCurrentTarget","locationInNode","convertToNodeSpace","getLocation","len","InitPoint","x","y","moveTo","clear","circle","onTouchMoved","AddPoint","lineTo","stroke","onTouchEnded","res","GetPoints","length","result","Recognize","log","Name","node","onLoad","start","update","dt"],"mappings":"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","file":"gestureTool.js","sourceRoot":"..\\..\\..\\..\\..\\assets\\Script\\Gesture","sourcesContent":["var DollarRecognizer = require(\"gestureHelp\");\r\nvar gesture = new DollarRecognizer();\r\n\r\ncc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n        // 声明 GestureAction_A 属性\r\n        GestureAction_A: {\r\n            default: null,\r\n            type: cc.Label\r\n        },\r\n        // 声明 GestureAction_B 属性\r\n        GestureAction_B: {\r\n            default: null,\r\n            type: cc.Label\r\n        },\r\n        // 声明 GestureAction_C 属性\r\n        GestureAction_C: {\r\n            default: null,\r\n            type: cc.Label\r\n        },\r\n        myGraphics:{\r\n            default: null,\r\n            type: cc.Graphics\r\n        }\r\n    },\r\n\r\n\r\n    //事件监听\r\n    setEventControl: function(){\r\n        var self = this;\r\n        var _isDown = false;\r\n\r\n        var graphics = this.myGraphics;\r\n        var gestureAction_A = this.GestureAction_A;\r\n        var gestureAction_B = this.GestureAction_B;\r\n        var gestureAction_C = this.GestureAction_C;\r\n\r\n        var gestureActionCount = 0;\r\n\r\n        cc.eventManager.addListener({\r\n        event: cc.EventListener.TOUCH_ONE_BY_ONE,\r\n            swallowTouches: true,\r\n              // 设置是否吞没事件，在 onTouchBegan 方法返回 true 时吞没\r\n            onTouchBegan: function (touch, event) {\r\n                if(gestureActionCount >= 3){\r\n                    gestureActionCount = 0;\r\n                    gestureAction_A.string = \"\";\r\n                    gestureAction_B.string = \"\";\r\n                    gestureAction_C.string = \"\";\r\n                }\r\n                //实现 onTouchBegan 事件回调函数\r\n                var target = event.getCurrentTarget();\r\n                // 获取事件所绑定的 target\r\n                var locationInNode = target.convertToNodeSpace(touch.getLocation());\r\n                _isDown = true;\r\n\r\n                var len = gesture.InitPoint(locationInNode.x,locationInNode.y);\r\n                // str = \"this.Unistrokes[] = new Unistroke(\"+\", new Array(new Point(\"+parseInt(locationInNode.x)+\",\"+parseInt(locationInNode.y)+\")\";\r\n                graphics.moveTo(0, 0);\r\n                graphics.clear();\r\n                graphics.circle(locationInNode.x, locationInNode.y, 2);\r\n                graphics.moveTo(locationInNode.x, locationInNode.y);\r\n                return true;\r\n            },\r\n            onTouchMoved: function (touch, event) {            // 触摸移动时触发\r\n                //实现 onTouchBegan 事件回调函数\r\n                var target = event.getCurrentTarget();\r\n                // 获取事件所绑定的 target\r\n                var locationInNode = target.convertToNodeSpace(touch.getLocation());\r\n                if (_isDown)\r\n                {\r\n                \tgesture.AddPoint(locationInNode.x,locationInNode.y);\r\n                \tgraphics.lineTo(locationInNode.x, locationInNode.y);\r\n                    graphics.stroke();\r\n                    // str += \",new Point(\"+parseInt(locationInNode.x)+\",\"+parseInt(locationInNode.y)+\")\";\r\n                }\r\n\r\n            },\r\n            onTouchEnded: function (touch, event) {            // 点击事件结束处理\r\n\r\n                if (_isDown)\r\n                {\r\n                    var res = \"\";\r\n                    _isDown = false;\r\n                    if (gesture.GetPoints().length >= 7)\r\n                    {\r\n                        // str += \"));\";\r\n\r\n                        // cc.log(\"集合: \" + str);\r\n                    \tvar result = gesture.Recognize(gesture.GetPoints(), 0);\r\n                    \t//判定手势操作\r\n                        cc.log(\"Result: \" + result.Name);\r\n                        res = result.Name;\r\n                        \r\n                    }\r\n                    else // fewer than 7 points were inputted\r\n                    {\r\n                    \t//当无法Recognize时，判定为点击操作\r\n                        // cc.log(\"Too few points made. Please try again.\");\r\n                        cc.log(\"Result: Tap\");\r\n                        res = \"Tap\";\r\n                    }\r\n\r\n                    //判定该展示在哪一个GestureAction中\r\n                    gestureActionCount ++;                    \r\n                    switch (gestureActionCount) {\r\n                        case 1://GestureAction_A\r\n                            gestureAction_A.string = res;\r\n                            break;\r\n                        case 2://GestureAction_B\r\n                            gestureAction_B.string = res;\r\n                            break;\r\n                        case 3://GestureAction_C\r\n                            gestureAction_C.string = res;\r\n                            break;\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n        }, self.node)\r\n    },\r\n    // use this for initialization\r\n    onLoad: function () {\r\n\r\n        //触摸监听\r\n        this.setEventControl();\r\n\r\n    },\r\n\r\n    start () {\r\n\r\n    },\r\n\r\n    // called every frame\r\n    update: function (dt) {\r\n\r\n    },\r\n});\r\n"]}